#Grammar grammar:
#{RULE} : {EXPRESSION1} | {EXPRESSION2}
#[String containing characters to be escaped (|, space, etc.)]
#[\Escaped escaped character] (?)
#[{RULE}* or {RULE}+]
#@TODO: Escape chars? Need to look into this more ('\n' in text vs \n newline, etc.)


{TOKEN} : {IDENTIFIER} | {BOOLEAN} | {NUMBER} | {CHARACTER} | {STRING} | ( | ) | #\( | #u8( | ' | ` | , | ,@ | .
{DELIMITER} : {WHITESPACE} | {VERTICAL_LINE} | ( | ) | " | ;
{INTRALINE_WHITESPACE} : [\ ] | [\t]
#@CHANGE: For parsing
#Old: {INTRALINE_WHITESPACE} : {SPACE_OR_TAB}
#New: {INTRALINE_WHITESPACE} : [ ] | [\t]
{WHITESPACE} : {INTRALINE_WHITESPACE} | {LINE_ENDING}
{VERTICAL_LINE} : [|]
{LINE_ENDING} : [\n] | [\r] [\n] | [\r]

#@CHANGE: For escape purposes (I think this is what they mean in the grammar)
#@TODO: Add more comment chars, if necessary
#Old: {LINE_ENDING} : {NEWLINE} | {RETURN} {NEWLINE} | {RETURN}
#New: {LINE_ENDING} : [\n] | [\r] [\n] | [\r]
{COMMENT} : ; [{COMMENT_CHARACTER}*] {LINE_ENDING} | {NESTED_COMMENT} | #; {INTERTOKEN_SPACE} {DATUM}
{COMMENT_CHARACTER}: {SUBSEQUENT}
#Letters, digits, most of the other chars (! | $ | % | & | * | / | : | < | = | > | ? | ^ | _ | ~ | . | @ | + | -)
#@TODO: Add [, ], {, }, |, # maybe some others

#@CHANGE: For parsing purposes
#Old: {COMMENT} : ; [{ALL_SUBSEQUENT_CHARACTERS_UP_TO_A_LINE_ENDING}] | {NESTED_COMMENT} | #; {INTERTOKEN_SPACE} {DATUM}
#New: {COMMENT} : ; [{COMMENT_CHARACTER}*] {LINE_ENDING} | {NESTED_COMMENT} | #; {INTERTOKEN_SPACE} {DATUM}
{NESTED_COMMENT} : [#|] {COMMENT_TEXT} [{COMMENT_CONT}*] [|#]

#@CHANGE: For parsing purposes
#Old: {COMMENT_TEXT} : [{character sequence not containing #| or |#}]
#New: {COMMENT_TEXT} : {COMMENT_CHARACTER}*
{COMMENT_TEXT} : {COMMENT_CHARACTER}*
#@TODO: When adding | and # to {COMMENT_CHARACTER}, make sure they don't get added here
{COMMENT_CONT} : {NESTED_COMMENT} {COMMENT_TEXT}
{DIRECTIVE} : #!fold-case | #!no-fold-case
{SPACE_OR_TAB} : \n | \t

{ATMOSPHERE} : {WHITESPACE} | {COMMENT} | {DIRECTIVE}
{INTERTOKEN_SPACE} : [{ATMOSPHERE}*]

{IDENTIFIER} : {INITIAL} [{SUBSEQUENT}*] | {VERTICAL_LINE} [{SYMBOL_ELEMENT}*] {VERTICAL_LINE} | {PECULIAR_IDENTIFIER}
{INITIAL} : {LETTER} | {SPECIAL_INITIAL}
{LETTER} : a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
{SPECIAL_INITIAL} : ! | $ | % | & | * | / | : | < | = | > | ? | ^ | _ | ~
{SUBSEQUENT} : {INITIAL} | {DIGIT} | {SPECIAL_SUBSEQUENT}
{DIGIT} : 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
{HEX_DIGIT} : {DIGIT} | a | b | c | d | e | f | A | B | C | D | E | F
{EXPLICIT_SIGN} : + | -
{SPECIAL_SUBSEQUENT} : {EXPLICIT_SIGN} | . | @
{INLINE_HEX_ESCAPE} : \x{HEX_SCALAR_VALUE};
{HEX_SCALAR_VALUE} : [{HEX_DIGIT}+]
{MNEMONIC_ESCAPE} : \a | \b | \t | \n | \r
{PECULIAR_IDENTIFIER} : {EXPLICIT_SIGN} | {EXPLICIT_SIGN} {SIGN_SUBSEQUENT} [{SUBSEQUENT}*] | {EXPLICIT_SIGN} . {DOT_SUBSEQUENT} [{SUBSEQUENT}*] | . {DOT_SUBSEQUENT} [{SUBSEQUENT}*]
{DOT_SUBSEQUENT} : {SIGN_SUBSEQUENT} | .

{SIGN_SUBSEQUENT} : {INITIAL} | {EXPLICIT_SIGN} | @
{SYMBOL_ELEMENT} : [{any character other than {VERTICAL_LINE} or \}]| {INLINE_HEX_ESCAPE} | {MNEMONIC_ESCAPE} | \[|]
#@CHANGE: For parsing purposes
#Old: {SYMBOL_ELEMENT} : [{any character other than {VERTICAL_LINE} or \}]| {INLINE_HEX_ESCAPE} | {MNEMONIC_ESCAPE} | \[|]

#New: {SYMBOL_ELEMENT} : {SUBSEQUENT} | {INLINE_HEX_ESCAPE} | {MNEMONIC_ESCAPE} | \[|]
{SYMBOL_ELEMENT} : {SUBSEQUENT} | {INLINE_HEX_ESCAPE} | {MNEMONIC_ESCAPE} | \[|]
#@TODO: Support the rest of the chars here, like for {COMMENT_CHARACTER}
{BOOLEAN} : #t | #f | #true | #false
{CHARACTER} : #\ {ANY_CHARACTER} | #\ {CHARACTER_NAME} | #\x{HEX_SCALAR_VALUE}
{CHARACTER_NAME} : alarm | backspace | delete | escape | newline | null | return | space | tab
{STRING} : " [{STRING_ELEMENT}*] "
{STRING_ELEMENT} : {SUBSEQUENT} | {MNEMONIC_ESCAPE} | \" | \\ | \[{INTRALINE_WHITESPACE}*]{LINE_ENDING} [{INTRALINE_WHITESPACE}*] | {INLINE_HEX_ESCAPE}
#@CHANGE: For parsing purposes
#Old: {STRING_ELEMENT} : [{any character other than " or \}] | {MNEMONIC_ESCAPE} | \" | \\ | \[{INTRALINE_WHITESPACE}*]{LINE_ENDING} [{INTRALINE_WHITESPACE}*] | {INLINE_HEX_ESCAPE}
#New:{STRING_ELEMENT} : {SUBSEQUENT} | {MNEMONIC_ESCAPE} | \" | \\ | \[{INTRALINE_WHITESPACE}*]{LINE_ENDING} [{INTRALINE_WHITESPACE}*] | {INLINE_HEX_ESCAPE}
#@TODO: Add the missing chars, as usual
{BYTEVECTOR} : #u8([{BYTE}*])
{BYTE} : {FIRST_DIGIT} {SECOND_DIGIT} {THIRD_DIGIT}
{FIRST_DIGIT} : 0 | 1 | 2
{SECOND_DIGIT} : {DIGIT} | {EMPTY}
{THIRD_DIGIT} : {DIGIT} | {EMPTY}
#@CHANGE: For parsing purposes
#Old: {BYTE} : [{ANY_EXACT_INTEGER_BETWEEN_0_AND_255}]
#New: {BYTE} : {FIRST_DIGIT} {SECOND_DIGIT} {THIRD_DIGIT}
#New: {FIRST_DIGIT} : 0 | 1 | 2
#New: {SECOND_DIGIT} : {DIGIT} | {EMPTY}
#New: {THIRD_DIGIT} : {DIGIT} | {EMPTY}
{NUMBER} : {NUM_2} | {NUM_8} | {NUM_10} | {NUM_16}

{NUM_10} : {PREFIX_10} (COMPLEX_10}
{COMPLEX_10} : {REAL_10} | {REAL_10} @ {REAL_10} | {REAL_10} + {UREAL_10} i | {REAL_10} - {UREAL_10} i | {REAL_10} + i | {REAL_10} - i | {REAL_10} {INFNAN} i | + {UREAL_10} i | - {UREAL_10} i | {INFNAN} i | + i | - i
{REAL_10} : {SIGN} {UREAL_10} | {INFNAN}
{UREAL_10} : {UINTEGER_10} | {UINTEGER_10} / {UINTEGER_10} | {DECIMAL_10}
{UINTEGER_10} : [{DIGIT_10}+]
{PREFIX_10} : {RADIX_10} {EXACTNESS} | {EXACTNESS} {RADIX_10}
{INFNAN} : +inf.0 | -inf.0 | +nan.0 | -nan.0

{NUM_2} : {PREFIX_2} (COMPLEX_2}
{COMPLEX_2} : {REAL_2} | {REAL_2} @ {REAL_2} | {REAL_2} + {UREAL_2} i | {REAL_2} - {UREAL_2} i | {REAL_2} + i | {REAL_2} - i | {REAL_2} {INFNAN} i | + {UREAL_2} i | - {UREAL_2} i | {INFNAN} i | + i | - i
{REAL_2} : {SIGN} {UREAL_2} | {INFNAN}
{UREAL_2} : {UINTEGER_2} | {UINTEGER_2} / {UINTEGER_2}
{UINTEGER_2} : [{DIGIT_2}+]
{PREFIX_2} : {RADIX_2} {EXACTNESS} | {EXACTNESS} {RADIX_2}
{INFNAN} : +inf.0 | -inf.0 | +nan.0 | -nan.0

{NUM_8} : {PREFIX_8} (COMPLEX_8}
{COMPLEX_8} : {REAL_8} | {REAL_8} @ {REAL_8} | {REAL_8} + {UREAL_8} i | {REAL_8} - {UREAL_8} i | {REAL_8} + i | {REAL_8} - i | {REAL_8} {INFNAN} i | + {UREAL_8} i | - {UREAL_8} i | {INFNAN} i | + i | - i
{REAL_8} : {SIGN} {UREAL_8} | {INFNAN}
{UREAL_8} : {UINTEGER_8} | {UINTEGER_8} / {UINTEGER_8}
{UINTEGER_8} : [{DIGIT_8}+]
{PREFIX_8} : {RADIX_8} {EXACTNESS} | {EXACTNESS} {RADIX_8}
{INFNAN} : +inf.0 | -inf.0 | +nan.0 | -nan.0

{NUM_16} : {PREFIX_16} (COMPLEX_16}
{COMPLEX_16} : {REAL_16} | {REAL_16} @ {REAL_16} | {REAL_16} + {UREAL_16} i | {REAL_16} - {UREAL_16} i | {REAL_16} + i | {REAL_16} - i | {REAL_16} {INFNAN} i | + {UREAL_16} i | - {UREAL_16} i | {INFNAN} i | + i | - i
{REAL_16} : {SIGN} {UREAL_16} | {INFNAN}
{UREAL_16} : {UINTEGER_16} | {UINTEGER_16} / {UINTEGER_16}
{UINTEGER_16} : [{DIGIT_16}+]
{PREFIX_16} : {RADIX_16} {EXACTNESS} | {EXACTNESS} {RADIX_16}
{INFNAN} : +inf.0 | -inf.0 | +nan.0 | -nan.0

{SUFFIX} : {EMPTY} | {EXPONENT_MARKER} {SIGN} [digit 10}+]
{EXPONENT_MARKER} : e
{SIGN} : {EMPTY} | + | -
{EXACTNESS} : {EMPTY} | #i | #e
{RADIX_2} : #b
{RADIX_8} : #o
{RADIX_10} : {EMPTY} | #d
{RADIX_16} : #x
{DIGIT_2} : 0 | 1
{DIGIT_8} : 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
{DIGIT_10} : {DIGIT}
{DIGIT_16} : {DIGIT_10} | a | b | c | d | e | f

{DATUM} : {SIMPLE_DATUM} | {COMPOUND_DATUM} | {LABEL} = {DATUM} | {LABEL} #
{SIMPLE_DATUM} : {BOOLEAN} | {NUMBER} | {CHARACTER} | {STRING} | {SYMBOL} | {BYTEVECTOR}
{SYMBOL} : {IDENTIFIER}
{COMPOUND_DATUM} : {LIST} | {VECTOR} | {ABBREVIATION}
{LIST} : ([{DATUM}*]) | ([{DATUM}+] . {DATUM})
{ABBREVIATION} : {ABBREV_PREFIX} {DATUM}
{ABBREV_PREFIX} : ' | ` | , | ,@
{VECTOR} : #([{DATUM}*])
{LABEL} : # {UINTEGER_10}

{EXPRESSION} : {IDENTIFIER} | {LITERAL} | {PROCEDURE_CALL} | {LAMBDA_EXPRESSION} | {CONDITIONAL} | {ASSIGNMENT} | {DERIVED_EXPRESSION} | {MACRO_USE} | {MACRO_BLOCK} | {INCLUDER}

{LITERAL} : {QUOTATION} | {SELF_EVALUATING}
{SELF_EVALUATING} : {BOOLEAN} | {NUMBER} | {VECTOR} | {CHARACTER} | {STRING} | {BYTEVECTOR}
{QUOTATION} : '{DATUM} | (quote {DATUM})
{PROCEDURE_CALL} : ({OPERATOR} [{OPERAND}*])
{OPERATOR} : {EXPRESSION}
{OPERAND} : {EXPRESSION}

{LAMBDA_EXPRESSION} : (lambda {FORMALS} {BODY})
{FORMALS} : ([{IDENTIFIER}*]) | {IDENTIFIER} | ([{IDENTIFIER}+] . {IDENTIFIER})
{BODY} : [{DEFINITION}*] {SEQUENCE}

#@TODO: This part is horrifying
{SEQUENCE} : [{COMMAND}*] {EXPRESSION}
{COMMAND} : {EXPRESSION}
{CONDITIONAL} : (if {TEST} {CONSEQUENT} {ALTERNATE})
{TEST} : {EXPRESSION}
{CONSEQUENT} : {EXPRESSION}
{ALTERNATE} : {EXPRESSION} | {EMPTY}
{ASSIGNMENT} : (set! {IDENTIFIER} {EXPRESSION})
{DERIVED_EXPRESSION} : (cond [{COND_CLAUSE}+] ) | (cond [{COND_CLAUSE}*] (else {SEQUENCE})) | (case {EXPRESSION} [{CASE_CLAUSE}+] ) | (case {EXPRESSION} [{CASE_CLAUSE}*] (else {sequence})) | (case {EXPRESSION} [{CASE_CLAUSE}*] (else => {RECIPIENT})) | (and [{TEST}*]) | (or [{TEST}*]) | (when {TEST} {SEQUENCE}) | (unless {TEST} {SEQUENCE}) | (let ([{BINDING_SPEC}*]) {BODY}) | (let {IDENTIFIER} ([{BINDING_SPEC}*]) {BODY}) | (let* ([{BINDING_SPEC}*]) {BODY}) | (letrec ([{BINDING_SPEC}*]) {BODY}) | (letrec* ([{BINDING_SPEC}*]) {BODY}) | (let-values ([{MV_BINDING_SPEC}*]) {BODY}) | (let*-values ([{MV_BINDING_SPEC}*]) {BODY}) | (begin {SEQUENCE}) | (do ([{ITERATION_SPEC}*]) ({TESTI_HDO_RESULT}) [{COMMAND}*]) | (delay {EXPRESSION}) | (delay-force {EXPRESSION}) | (parameterize [{DOUBLE_EXPRESSION}*]) {BODY}) | (guard ({IDENTIFIER} [{COND_CLAUSE}*]) {BODY}) | {QUASIQUOTATION} | (case-lambda [{CASE_LAMBDA_CLAUSE}*])
#@CHANGE: For parsing purposes
#Old body: (parameterize (({EXPRESSION} {EXPRESSION})*)
#New body: (parameterize [{DOUBLE_EXPRESSION}*])
#New: {DOUBLE_EXPRESSION}: ({EXPRESSION} {EXPRESSION})
{COND_CLAUSE} : ({TEST} {SEQUENCE}) | ({TEST}) | ({TEST} => {RECIPIENT})
{RECIPIENT} : {EXPRESSION}
{CASE_CLAUSE} : ([{DATUM}*]) {SEQUENCE}) | (([{DATUM}*]) => {RECIPIENT})

{BINDING_SPEC} : ({IDENTIFIER} {EXPRESSION})
{MV_BINDING_SPEC} : ({FORMALS} {EXPRESSION})
{ITERATION_SPEC} : ({IDENTIFIER} {INIT} {step]) | ({IDENTIFIER} {INIT})
{CASE_LAMBDA_CLAUSE} : ({FORMALS} {BODY})
{INIT} : {EXPRESSION}
{STEP} : {EXPRESSION}
{DO_RESULT} : {SEQUENCE} | {EMPTY}
{MACRO_USE} : ({KEYWORD} [{DATUM}*])
{KEYWORD} : {IDENTIFIER}
{MACRO_BLOCK} : (let-syntax ([{SYNTAX_SPEC}*]) {BODY}) | (letrec-syntax ([{SYNTAX_SPEC}*]) {BODY})
{SYNTAX_SPEC} : ({KEYWORD} {TRANSFORMER_SPEC})
{INCLUDER} : | (include [{STRING}+]) | (include-ci [{STRING}+])

{PROGRAM} : [{IMPORT_DECLARATION}+] [{COMMAND_OR_DEFINITION}+] {EOF}
#@CHANGE: For parsing
#Old: {PROGRAM} : [{IMPORT_DECLARATION}+] [{COMMAND_OR_DEFINITION}+]
#New: {PROGRAM} : [{IMPORT_DECLARATION}+] [{COMMAND_OR_DEFINITION}+] {EOF}
{COMMAND_OR_DEFINITION} : {COMMAND} | {DEFINITION} | (begin [{COMMAND_OR_DEFINITION}+])
{DEFINITION} : (define {IDENTIFIER} {EXPRESSION}) | (define ({IDENTIFIER} {DEF_FORMALS}) {BODY}) | {SYNTAX_DEFINITION} | (define-values {FORMALS} {BODY}) | (define-record-type {IDENTIFIER} {CONSTRUCTOR} {IDENTIFIER} [{FIELD_SPEC}*]) | (begin [{DEFINITION}*])
{DEF_FORMALS} : [{IDENTIFIER}*] | [{IDENTIFIER}*] . {IDENTIFIER}
{CONSTRUCTOR} : ({IDENTIFIER} [{FIELD_NAME}*])
{FIELD_SPEC} : ({FIELD_NAME} {ACCESSOR}) | ({FIELD_NAME} {ACCESSOR} {MUTATOR})
{FIELD_NAME} : {IDENTIFIER}

{ACCESSOR} : {IDENTIFIER}
{MUTATOR} : {IDENTIFIER}
{SYNTAX_DEFINITION} : (define-syntax {KEYWORD} {TRANSFORMER_SPEC})

{LIBRARY} : (define-library {LIBRARY_NAME} [{LIBRARY_DECLARATION}*])
{LIBRARY_NAME} : ([{LIBRARY_NAME_PART}+])
{LIBRARY_NAME_PART} : {IDENTIFIER} | {UINTEGER_10}
{LIBRARY_DECLARATION} : (export [{EXPORT_SPEC}*]) | {IMPORT_DECLARATION} | (begin [{COMMAND_OR_DEFINITION}*]) | {INCLUDER} | (include-library-declarations [{STRING}+] ) | (cond-expand [{COND_EXPAND_CLAUSE}+] ) | (cond-expand [{COND_EXPAND_CLAUSE}+] (else [{LIBRARY_DECLARATION}*]))
{IMPORT_DECLARATION} : (import [{IMPORT_SET}+])
{EXPORT_SPEC} : {IDENTIFIER} | (rename {IDENTIFIER} {IDENTIFIER})
{IMPORT_SET} : {LIBRARY_NAME} | (only {IMPORT_SET} [{IDENTIFIER}+]) | (except {IMPORT_SET} [{IDENTIFIER}+]) | (prefix {IMPORT_SET} {IDENTIFIER}) | (rename {IMPORT_SET} [{DOUBLE_IDENTIFIER}+])

#@CHANGE: Added this rule to make it easier to parse:
#Original: (rename {IMPORT_SET} [({IDENTIFIER} {IDENTIFIER})+])
#New: (rename {IMPORT_SET} [{DOUBLE_IDENTIFIER}+])
#New: {DOUBLE_IDENTIFIER}: ({IDENTIFIER} {IDENTIFIER})

{DOUBLE_IDENTIFIER}: ({IDENTIFIER} {IDENTIFIER})
{COND_EXPAND_CLAUSE} : ({FEATURE_REQUIREMENT} [{LIBRARY_DECLARATION}*])
{FEATURE_REQUIREMENT} : {IDENTIFIER} | {LIBRARY_NAME} | (and [{FEATURE_REQUIREMENT}*]) | (or [{FEATURE_REQUIREMENT}*]) | (not {FEATURE_REQUIREMENT})