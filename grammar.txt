#Grammar grammar:
#{RULE} : {EXPRESSION1} | {EXPRESSION2}
#[String containing characters to be escaped (|, space, etc.)]
#[\Escaped escaped character] (?)
#[{RULE}* or {RULE}+]
#["Regular expression"]


{TOKEN} : {IDENTIFIER} | {BOOLEAN} | {NUMBER} | {CHARACTER} | {STRING} | ( | ) | #\( | #u8( | ' | ` | , | ,@ | .
{DELIMITER} : {WHITESPACE} | {VERTICAL_LINE} | ( | ) | " | ;
{INTRALINE_WHITESPACE} : {SPACE_OR_TAB}
{WHITESPACE} : {INTRALINE_WHITESPACE} | {LINE_ENDING}
{VERTICAL_LINE} : [|]
{LINE_ENDING} : {NEWLINE} | {RETURN} {NEWLINE} | {RETURN}
{COMMENT} : ; [{all subsequent characters up to a line ending}] | {NESTED_COMMENT} | #; {INTERTOKEN_SPACE} {DATUM}
{NESTED_COMMENT} : [#|] {COMMENT_TEXT} [{COMMENT_CONT}*] |#
{COMMENT_TEXT} : [{character sequence not containing #| or |#}]
{COMMENT_CONT} : {NESTED_COMMENT} {COMMENT_TEXT}
{DIRECTIVE} : #!fold-case | #!no-fold-case
{SPACE_OR_TAB} : \n | \t

{atmosphere} : {whitespace} | {comment} | {directive}
{intertoken space} : [{atmosphere}*]

{identifier} : {initial} [{subsequent}*] | {vertical line} [{symbol element}*] {vertical line} | {peculiar identifier}
{initial} : {letter} | {special initial}
{letter} : a | b | c | ... | z | A | B | C | ... | Z
{special initial} : ! | $ | % | & | * | / | : | < | = | > | ? | ^ | _ | ~
{subsequent} : {initial} | {digit} | {special subsequent}
{digit} : 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
{hex digit} : {digit} | a | b | c | d | e | f
{explicit sign} : + | -
{special subsequent} : {explicit sign} | . | @
{inline hex escape} : \x{hex scalar value};
{hex scalar value} : [{hex digit}+]
{mnemonic escape} : \a | \b | \t | \n | \r
{peculiar identifier} : {explicit sign} | {explicit sign} {sign subsequent} [{subsequent}*] | {explicit sign} . {dot subsequent} [{subsequent}*] | . {dot subsequent} [{subsequent}*]
{dot subsequent} : {sign subsequent} | .

{sign subsequent} : {initial} | {explicit sign} | @
{symbol element} : [{any character other than {vertical line} or \}]| {inline hex escape} | {mnemonic escape} | \[|]
{boolean} : #t | #f | #true | #false
{character} : #\ {any character} | #\ {character name} | #\x{hex scalar value}
{character name} : alarm | backspace | delete | escape | newline | null | return | space | tab
{string} : " [{string element}*] "
{string element} : [{any character other than " or \}] | {mnemonic escape} | \" | \\ | \[{intraline whitespace}*]{line ending} [{intraline whitespace}*] | {inline hex escape}
{bytevector} : #u8([{byte}*])
{byte} : [{any exact integer between 0 and 255}]
{number} : {num 2} | {num 8} | {num 10} | {num 16}

{num 10} : {prefix 10} (complex 10}
{complex 10} : {real 10} | {real 10} @ {real 10} | {real 10} + {ureal 10} i | {real 10} - {ureal 10} i | {real 10} + i | {real 10} - i | {real 10} {infnan} i | + {ureal 10} i | - {ureal 10} i | {infnan} i | + i | - i
{real 10} : {sign} {ureal 10} | {infnan}
{ureal 10} : {uinteger 10} | {uinteger 10} / {uinteger 10} | {decimal 10}
{uinteger 10} : [{digit 10}+]
{prefix 10} : {radix 10} {exactness} | {exactness} {radix 10}
{infnan} : +inf.0 | -inf.0 | +nan.0 | -nan.0

{num 2} : {prefix 2} (complex 2}
{complex 2} : {real 2} | {real 2} @ {real 2} | {real 2} + {ureal 2} i | {real 2} - {ureal 2} i | {real 2} + i | {real 2} - i | {real 2} {infnan} i | + {ureal 2} i | - {ureal 2} i | {infnan} i | + i | - i
{real 2} : {sign} {ureal 2} | {infnan}
{ureal 2} : {uinteger 2} | {uinteger 2} / {uinteger 2}
{uinteger 2} : [{digit 2}+]
{prefix 2} : {radix 2} {exactness} | {exactness} {radix 2}
{infnan} : +inf.0 | -inf.0 | +nan.0 | -nan.0

{num 8} : {prefix 8} (complex 8}
{complex 8} : {real 8} | {real 8} @ {real 8} | {real 8} + {ureal 8} i | {real 8} - {ureal 8} i | {real 8} + i | {real 8} - i | {real 8} {infnan} i | + {ureal 8} i | - {ureal 8} i | {infnan} i | + i | - i
{real 8} : {sign} {ureal 8} | {infnan}
{ureal 8} : {uinteger 8} | {uinteger 8} / {uinteger 8}
{uinteger 8} : [{digit 8}+]
{prefix 8} : {radix 8} {exactness} | {exactness} {radix 8}
{infnan} : +inf.0 | -inf.0 | +nan.0 | -nan.0

{num 16} : {prefix 16} (complex 16}
{complex 16} : {real 16} | {real 16} @ {real 16} | {real 16} + {ureal 16} i | {real 16} - {ureal 16} i | {real 16} + i | {real 16} - i | {real 16} {infnan} i | + {ureal 16} i | - {ureal 16} i | {infnan} i | + i | - i
{real 16} : {sign} {ureal 16} | {infnan}
{ureal 16} : {uinteger 16} | {uinteger 16} / {uinteger 16}
{uinteger 16} : [{digit 16}+]
{prefix 16} : {radix 16} {exactness} | {exactness} {radix 16}
{infnan} : +inf.0 | -inf.0 | +nan.0 | -nan.0

{suffix} : {empty} | {exponent marker} {sign} [digit 10}+]
{exponent marker} : e
{sign} : {empty} | + | -
{exactness} : {empty} | #i | #e
{radix 2} : #b
{radix 8} : #o
{radix 10} : {empty} | #d
{radix 16} : #x
{digit 2} : 0 | 1
{digit 8} : 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
{digit 10} : {digit}
{digit 16} : {digit 10} | a | b | c | d | e | f

{datum} : {simple datum} | {compound datum} | {label} = {datum} | {label} #
{simple datum} : {boolean} | {number} | {character} | {string} | {symbol} | {bytevector}
{symbol} : {identifier}
{compound datum} : {list} | {vector} | {abbreviation}
{list} : ([{datum}*]) | ([{datum}+] . [datum])
{abbreviation} : {abbrev prefix} {datum}
{abbrev prefix} : ' | ` | , | ,@
{vector} : #([{datum}*])
{label} : # {uinteger 10}

{expression} : {identifier} | {literal} | {procedure call} | {lambda expression} | {conditional} | {assignment} | {derived expression} | {macro use} | {macro block} | {includer}

{literal} : {quotation} | {self-evaluating}
{self-evaluating} : {boolean} | {number} | {vector} | {character} | {string} | {bytevector}
{quotation} : '{datum} | (quote {datum})
{procedure call} : ({operator} [{operand}*])
{operator} : {expression}
{operand} : {expression}

{lambda expression} : (lambda {formals} {body})
{formals} : ([*identifier}*]) | {identifier} | ([{identifier}+] . {identifier})
{body} : [{definition}*] {sequence}
{sequence} : [{command}*] {expression}
{command} : {expression}
{conditional} : (if {test} {consequent} {alternate})
{test} : {expression}
{consequent} : {expression}
{alternate} : {expression} | {empty}
{assignment} : (set! {identifier} {expression})
{derived expression} : (cond [{cond clause}+] ) | (cond [{cond clause}*] (else {sequence})) | (case {expression} [{case clause}+] ) | (case {expression} [{case clause}*] (else hsequencei)) | (case {expression} [{case clause}*] (else => {recipient})) | (and [{test}*]) | (or [{test}*]) | (when {test} {sequence}) | (unless {test} {sequence}) | (let ([{binding spec}*]) {body}) | (let {identifier} ([{binding spec}*]) {body}) | (let* ([{binding spec}*]) {body}) | (letrec ([{binding spec}*]) {body}) | (letrec* ([{binding spec}*]) {body}) | (let-values ([{mv binding spec}*]) {body}) | (let*-values ([{mv binding spec}*]) {body}) | (begin {sequence}) | (do ([{iteration spec}*]) ({testi hdo result}) [{command}*]) | (delay {expression}) | (delay-force {expression}) | (parameterize (({expression} [{expression})*]) {body}) | (guard ({identifier} [{cond clause}*]) {body}) | {quasiquotation} | (case-lambda [{case-lambda clause}*])
{cond clause} : ({test} {sequence}) | ({test}) | ({test} => {recipient})
{recipient} : {expression}
{case clause} : ([{hdatum}*]) {sequence}) | (([{datum}*]) => {recipient})

{binding spec} : (hidentifieri hexpressioni)
{mv binding spec} : (hformalsi hexpressioni)
{iteration spec} : (hidentifieri {init} hstepi) | (hidentifieri hiniti)
hcase-lambda clausei : (hformalsi hbodyi)
{init} : {expression}
{step} : {expression}
{do result} : {sequence} | {empty}
{macro use} : (hkeywordi {datum}*)
{keyword} : {identifier}
{macro block} :
(let-syntax (hsyntax speci*) hbodyi) | (letrec-syntax (hsyntax speci*) hbodyi)
{syntax spec} : (hkeywordi htransformer speci)
{includer} : | (include {string} + ) | (include-ci {string} + )

{program} :
{import declaration} +
{command or definition} +
{command or definition} : {command} | {definition} | (begin {command or definition} + )
{definition} : (define {identifier} hexpressioni) | (define (hidentifieri hdef formalsi) hbodyi) | {syntax definition} | (define-values {formals} hbodyi) | (define-record-type {identifier}
{constructori hidentifier} {field spec}*) | (begin {definition}*)
{def formals} : {identifier}* | {identifier}* . {identifier}
{constructor} : (hidentifieri {field name}*)
{field spec} : (hfield namei haccessori) | (hfield namei {accessor} hmutatori)
{field name} : {identifier}
7. Formal syntax and semantics 65
{accessor} : {identifier}
{mutator} : {identifier}
{syntax definition} :
(define-syntax {keyword} htransformer speci)

{library} :
(define-library {library name}
{library declaration}*)
{library name} : (hlibrary name parti + )
{library name part} : {identifier} | huinteger 10i
{library declaration} : (export {export spec}*) | {import declaration} | (begin {command or definition}*) | {includer} | (include-library-declarations {string} + ) | (cond-expand hcond-expand clausei + ) | (cond-expand hcond-expand clausei +
(else {library declaration}*))
{import declaration} : (import {import set} + )
{export spec} : {identifier} | (rename {identifier} hidentifieri)
{import set} : {library name} | (only {import seti hidentifier} + ) | (except {import seti hidentifier} + ) | (prefix {import set} hidentifieri) | (rename {import set} (hidentifieri hidentifieri) + )
hcond-expand clausei :
(hfeature requirementi {library declaration}*)
{feature requirement} : {identifier} | {library name} | (and {feature requirement}*) | (or {feature requirement}*) | (not hfeature requirementi)